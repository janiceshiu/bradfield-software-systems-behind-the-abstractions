from typing import Generator
from stream import Stream
from collections import namedtuple
import math, operator, string

### Scanner Start

# Tokens are generated by `scan/1`. Used by `parse/1`
Token = namedtuple('Token', ('type', 'value'))

OPERATORS = {
  '+': operator.add,
  '-': operator.sub,
  '*': operator.mul,
  '/': operator.truediv,
}
PARENTHESES = {
  '(': 'LEFT_PAREN',
  ')': 'RIGHT_PAREN'
}
WHITESPACE = '\n\t '
DIGITS = '0123456789'
KEYWORDS = ['def']

NAME_START_CHARS = string.ascii_letters + '_'
NAME_CHARS = NAME_START_CHARS + string.digits

NAMESPACE = {
    'sqrt': math.sqrt,
    'sin': math.sin,
    'cos': math.cos,
    'tan': math.tan,
    'exp': math.exp,
    'fact': math.factorial,
    'pi': math.pi
}

def scan(text: str) -> Generator:
  """
  Takes a string, scans it, returns a generator of tokens
  """
  characters = Stream(text)

  while not characters.at_end():
    character = characters.take()
    if character in OPERATORS:
      yield Token('OPERATOR', character)
    elif character in PARENTHESES:
      yield Token(PARENTHESES[character], character)
    elif character in WHITESPACE:
      pass
    elif character in DIGITS:
      characters.backward()
      yield Token('NUMBER', take_number(characters))
    elif character in NAME_START_CHARS:
      characters.backward()
      name = take_name(characters)
      if name in KEYWORDS:
        yield Token('KEYWORD', name)
      else:
        yield Token ('NAME', name)
    else:
      raise ValueError(character)

def take_number(stream):
  number = []
  while not stream.at_end() and stream.peek() in DIGITS:
    number.append(stream.take())
  return ''.join(number)

def take_name(stream):
  name = []
  while not stream.at_end() and stream.peek() in NAME_CHARS:
    name.append(stream.take())

  return ''.join(name)

### Parser start

## GRAMMAR
# statement = function_definition | add_sub
# function_definition = def name '(' name ')' add_sub
# add_sub = mul_div ZERO_OR_MORE( ('+' | '-') mul_div )
# mul_div = operand ZERO_OR_MORE(('*' | '/') operand)
# operand = number | '(' add_sub ')' | name(add_sub)

# All functions for the grammar are in the format `parse_grammar_name/1`
# Eg: `statement` parsing is implemented in `parse_statement/1`

## AST nodes are generated by `parse/1` and used by `evaluate/1`
FunctionCall = namedtuple(
  'FunctionCall',
  ('name', 'argument')
)

FunctionDefinition = namedtuple(
  'FunctionDefinition',
  ('function_name', 'argument_name', 'function_body')
)

VariableName = namedtuple(
  'VariableName',
  ('name',) # need trailing comma because this is a 1-item tuple
)

def parse(tokens):
  stream = Stream(tokens)
  parsed = parse_statement(stream)
  if not stream.at_end():
    raise SyntaxError(f"Unconsumed tokens. Next token: {stream.peek()}")
  return parsed

def parse_statement(tokens):
  if tokens.peek() == Token('KEYWORD', 'def'):
    return parse_function_definition(tokens)

  return parse_add_sub(tokens)

def parse_function_definition(tokens):
  # The line below should never raise a syntax error because `parse_statement/1`
  # already checks that this token is Token('KEYWORD', 'def').
  # However, we are leaving this check in because
  # 1. We need to take the token
  # 2. Sanity-checking is good practice
  take_matching_token(tokens, 'KEYWORD', 'def')

  function_name = take_matching_token(tokens, 'NAME').value
  take_matching_token(tokens, 'LEFT_PAREN')
  argument_name = take_matching_token(tokens, 'NAME').value
  take_matching_token(tokens, 'RIGHT_PAREN')
  function_body = parse_add_sub(tokens)

  return FunctionDefinition(function_name, argument_name, function_body)

def parse_add_sub(tokens):
  expression = parse_mul_div(tokens)

  while not tokens.at_end() and tokens.peek().type == 'OPERATOR' and tokens.peek().value in '+-':
    operator = tokens.take().value
    right = parse_mul_div(tokens)
    expression = (expression, operator, right)

  return expression

def parse_mul_div(tokens):
  expression = parse_operand(tokens)

  while not tokens.at_end() and tokens.peek().type == 'OPERATOR' and tokens.peek().value in '*/':
    operator = tokens.take().value
    right = parse_operand(tokens)
    expression = (expression, operator, right)

  return expression

def parse_operand(tokens):
  token = tokens.take()
  if token.type == 'NUMBER':
    return token.value
  elif token.type == 'LEFT_PAREN':
    add_sub = parse_add_sub(tokens)
    take_matching_token(tokens, 'RIGHT_PAREN')
    return add_sub
  elif token.type == "NAME":
    if not tokens.at_end() and tokens.peek().type == 'LEFT_PAREN':
      take_matching_token(tokens, 'LEFT_PAREN')
      add_sub = parse_add_sub(tokens)
      take_matching_token(tokens, 'RIGHT_PAREN')
      return FunctionCall(token.value, add_sub)
    else:
      # support for user-defined variables
      return VariableName(token.value)

  raise SyntaxError(tokens.peek())

def take_matching_token(stream, expected_type, expected_value=None):
    token = stream.take()

    if expected_value is None:
      # For this part, we only want to match the token type
      # So if `expected_type` = 'OPERATOR' and `expected_value` = None,
      # Token('OPERATOR', '*') matches
      # Token('OPERATOR', '/') also matches
      if expected_type != token.type:
        raise SyntaxError(f"Expected {expected_type}, got {token}")
    elif expected_value != token.value or expected_type != token.type:
      # For this part, we want to match both token type AND value.
      # So if `expected_type` = 'OPERATOR' and `expected_value` = '/'
      # Token('OPERATOR', '*') does not match
      # Token('OPERATOR', '/') will match
      raise SyntaxError(f"Expected Token({expected_type}, {expected_value}) got {token}")

    return token

### Evaluator start
def evaluate(ast):
  match ast:
    case str(_):
      return int(ast)
    case FunctionCall(name=name, argument=argument):
      if name in NAMESPACE:
        function_definition = NAMESPACE[name]
        return function_definition(evaluate(argument))
      else:
        raise NameError(f"Undefined variable: {name}")
    case FunctionDefinition(function_name=function_name, argument_name=argument_name, function_body=function_body):
      NAMESPACE[function_name] = lambda argument: evaluate_function(argument_name, function_body, argument)
    case VariableName(name=name):
      if name in NAMESPACE:
        return NAMESPACE[name]
      else:
        raise NameError(f"Undefined variable: {name}")
    case (left, operator, right):
      operator_function = OPERATORS[operator]
      return operator_function(evaluate(left), evaluate(right))
    case _:
      raise ValueError(f"Not implemented {ast}")

def evaluate_function(argument_name, function_body, argument):
  print("Evaluate function: ", argument_name, function_body, argument)
  NAMESPACE[argument_name] = argument
  return evaluate(function_body)

### Repl start
def repl():
   while True:
     text = input('calc > ')
     scanned = list(scan(text))
     print(f"List of tokens from scanner:\n{scanned}\n")
     parsed = parse(scanned)
     print(f"AST from parser:\n{parsed}\n")
     eval = evaluate(parsed)
     print(f"Result from evaluator: {eval}")


### Testing Start
import pytest

@pytest.mark.parametrize('text,tokens', [
  ('189', [Token('NUMBER', '189')]),
  ('8 + 19', [Token('NUMBER', '8'), Token('OPERATOR', '+'), Token('NUMBER', '19')]),
  ('(1 + 2)', [Token('LEFT_PAREN', '('), Token('NUMBER', '1'), Token('OPERATOR', '+'), Token('NUMBER', '2'), Token('RIGHT_PAREN', ')')]),
])
def test_scan(text, tokens):
    assert list(scan(text)) == tokens

@pytest.mark.parametrize('text,ast', [
  ('189', '189'),
  ('189 + 54', ('189', '+', '54')),
  ('1 + 1 * 3 +7', (('1', '+', ('1', '*', '3')), '+', '7')),
  ('189 + 54', ('189', '+', '54')),
  ('def square(x) x * x', FunctionDefinition('square', 'x', (VariableName('x'), '*', VariableName('x')))),
])
def test_parse(text, ast):
  assert parse(scan(text)) == ast

@pytest.mark.parametrize('text,value', [
    ('1234', 1234),
    ('1 + 7', 8),
    ('9 / 3', 3),
    ('1 * 2 * 3 * 4', 24),
    ('sin(0)', 0),
    ('fact(5)', 120),
    ('cos(sin(0)) + 18', 19)
])
def test_evaluate(text, value):
  assert evaluate(parse(scan(text))) == value

def test_function_definition():
  evaluate(parse(scan("def square(x) x * x")))
  print(f"NAMESPACE['square']: {NAMESPACE['square']}")
  print(f"Parsed AST after defining 'square' in earlier call: {parse(scan('square(5)'))}")
  assert evaluate(parse(scan("square(5)"))) == 25

if __name__ == '__main__':
  repl()
